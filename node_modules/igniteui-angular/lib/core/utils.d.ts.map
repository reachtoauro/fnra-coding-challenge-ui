{"version":3,"file":"utils.d.ts","sources":["utils.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Observable } from 'rxjs';\n/**\n * @hidden\n */\nexport declare function cloneArray(array: any[], deep?: boolean): any[];\n/**\n * Doesn't clone leaf items\n * @hidden\n */\nexport declare function cloneHierarchicalArray(array: any[], childDataKey: any): any[];\n/**\n * Deep clones all first level keys of Obj2 and merges them to Obj1\n * @param obj1 Object to merge into\n * @param obj2 Object to merge from\n * @returns Obj1 with merged cloned keys from Obj2\n * @hidden\n */\nexport declare function mergeObjects(obj1: {}, obj2: {}): any;\n/**\n * Creates deep clone of provided value.\n * Supports primitive values, dates and objects.\n * If passed value is array returns shallow copy of the array.\n * @param value value to clone\n * @returns Deep copy of provided value\n * @hidden\n */\nexport declare function cloneValue(value: any): any;\n/**\n * Checks if provided variable is Object\n * @param value Value to check\n * @returns true if provided variable is Object\n * @hidden\n */\nexport declare function isObject(value: any): boolean;\n/**\n * Checks if provided variable is Date\n * @param value Value to check\n * @returns true if provided variable is Date\n * @hidden\n */\nexport declare function isDate(value: any): boolean;\n/**\n * Parse provided input to Date.\n * @param value input to parse\n * @returns Date if parse succeed or null\n * @hidden\n */\nexport declare function parseDate(value: any): Date | null;\n/**\n * Returns an array with unique dates only.\n * @param columnValues collection of date values (might be numbers or ISO 8601 strings)\n * @returns collection of unique dates.\n * @hidden\n */\nexport declare function uniqueDates(columnValues: any[]): any;\n/**\n * Checks if the two passed arguments are equal\n * Currently supports date objects\n * @param obj1\n * @param obj2\n * @returns: `boolean`\n * @hidden\n */\nexport declare function isEqual(obj1: any, obj2: any): boolean;\n/**\n * @hidden\n */\nexport declare const enum KEYCODES {\n    ENTER = 13,\n    SPACE = 32,\n    ESCAPE = 27,\n    LEFT_ARROW = 37,\n    UP_ARROW = 38,\n    RIGHT_ARROW = 39,\n    DOWN_ARROW = 40,\n    F2 = 113,\n    TAB = 9,\n    CTRL = 17,\n    Z = 90,\n    Y = 89,\n    X = 88,\n    BACKSPACE = 8,\n    DELETE = 46,\n    INPUT_METHOD = 229\n}\n/**\n * @hidden\n */\nexport declare const enum KEYS {\n    ENTER = \"Enter\",\n    SPACE = \" \",\n    SPACE_IE = \"Spacebar\",\n    ESCAPE = \"Escape\",\n    ESCAPE_IE = \"Esc\",\n    LEFT_ARROW = \"ArrowLeft\",\n    LEFT_ARROW_IE = \"Left\",\n    UP_ARROW = \"ArrowUp\",\n    UP_ARROW_IE = \"Up\",\n    RIGHT_ARROW = \"ArrowRight\",\n    RIGHT_ARROW_IE = \"Right\",\n    DOWN_ARROW = \"ArrowDown\",\n    DOWN_ARROW_IE = \"Down\",\n    F2 = \"F2\",\n    TAB = \"Tab\",\n    SEMICOLON = \";\",\n    HOME = \"Home\",\n    END = \"End\"\n}\n/**\n * @hidden\n * Returns the actual size of the node content, using Range\n * ```typescript\n * let range = document.createRange();\n * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];\n *\n * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);\n * ```\n */\nexport declare function getNodeSizeViaRange(range: Range, node: any): number;\n/**\n * @hidden\n * Returns the actual size of the node content, using Canvas\n * ```typescript\n * let ctx = document.createElement('canvas').getContext('2d');\n * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];\n *\n * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);\n * ```\n */\nexport declare function getNodeSizeViaCanvas(canvas2dCtx: any, node: any): number;\n/**\n * @hidden\n */\nexport declare function isIE(): boolean;\n/**\n * @hidden\n */\nexport declare function isEdge(): boolean;\n/**\n * @hidden\n */\nexport declare function isFirefox(): boolean;\n/**\n * @hidden\n */\nexport declare class PlatformUtil {\n    private platformId;\n    isBrowser: boolean;\n    isIOS: boolean;\n    constructor(platformId: Object);\n}\n/**\n * @hidden\n */\nexport declare function isLeftClick(event: PointerEvent): boolean;\n/** @hidden */\nexport declare function isNavigationKey(key: string): boolean;\n/**\n * @hidden\n */\nexport declare function flatten(arr: any[]): any[];\nexport interface CancelableEventArgs {\n    /**\n     * Provides the ability to cancel the event.\n     */\n    cancel: boolean;\n}\nexport interface IBaseEventArgs {\n    /**\n     * Provides reference to the owner component.\n     */\n    owner?: any;\n}\nexport interface CancelableBrowserEventArgs extends CancelableEventArgs {\n    /** Browser event */\n    event?: Event;\n}\nexport interface IBaseCancelableBrowserEventArgs extends CancelableBrowserEventArgs, IBaseEventArgs {\n}\nexport interface IBaseCancelableEventArgs extends CancelableEventArgs, IBaseEventArgs {\n}\nexport declare const HORIZONTAL_NAV_KEYS: Set<string>;\nexport declare const NAVIGATION_KEYS: Set<string>;\nexport declare const ROW_EXPAND_KEYS: Set<string>;\nexport declare const ROW_COLLAPSE_KEYS: Set<string>;\nexport declare const ROW_ADD_KEYS: Set<string>;\nexport declare const SUPPORTED_KEYS: Set<string>;\nexport declare const HEADER_KEYS: Set<string>;\n/**\n * @hidden\n * @internal\n *\n * Creates a new ResizeObserver on `target` and returns it as an Observable.\n * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.\n * Related issue: https://github.com/angular/angular/issues/31712\n */\nexport declare function resizeObservable(target: HTMLElement): Observable<ResizeObserverEntry[]>;\n/**\n * @hidden\n * @internal\n *\n * Compares two maps.\n */\nexport declare function compareMaps(map1: Map<any, any>, map2: Map<any, any>): boolean;\n/**\n *\n * Given a property access path in the format `x.y.z` resolves and returns\n * the value of the `z` property in the passed object.\n *\n * @hidden\n * @internal\n */\nexport declare function resolveNestedPath(obj: any, path: string): any;\n/**\n *\n * Given a property access path in the format `x.y.z` and a value\n * this functions builds and returns an object following the access path.\n *\n * @example\n * ```typescript\n * console.log('x.y.z.', 42);\n * >> { x: { y: { z: 42 } } }\n * ```\n *\n * @hidden\n * @internal\n */\nexport declare function reverseMapper(path: string, value: any): {};\nexport declare function yieldingLoop(count: number, chunkSize: number, callback: (index: number) => void, done: () => void): void;\nexport declare function mkenum<T extends {\n    [index: string]: U;\n}, U extends string>(x: T): T;\n"]}